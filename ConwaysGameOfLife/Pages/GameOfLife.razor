@page "/"
@using System.Net.Http.Json
@using System.Timers
@implements IDisposable
@inject IJSRuntime JS
@inject HttpClient Http

<div class="container">
    <h1>Conway's Game of Life + AI Visualization</h1>
    
    <div class="game-controls">
        <button @onclick="ToggleSimulation" class="control-button @(IsRunning ? "pause" : "start")">
            @(IsRunning ? "Pause" : "Start")
        </button>
        <button @onclick="ResetGrid" class="control-button reset">Reset</button>
        
        <div class="pattern-select">
            <select @bind="SelectedPattern" class="pattern-dropdown">
                <option value="">-- Select Pattern --</option>
                <optgroup label="Oscillators">
                    <option value="blinker">Blinker</option>
                    <option value="toad">Toad</option>
                    <option value="beacon">Beacon</option>
                    <option value="pulsar">Pulsar</option>
                </optgroup>
                <optgroup label="Spaceships">
                    <option value="glider">Glider</option>
                    <option value="lwss">Lightweight Spaceship</option>
                </optgroup>
                <optgroup label="Other">
                    <option value="random">Random</option>
                    <option value="glider_gun">Gosper Glider Gun</option>
                </optgroup>
            </select>
            <button @onclick="ApplySelectedPattern" class="control-button apply-pattern">Apply Pattern</button>
        </div>
        
        <button @onclick="GenerateImage" class="control-button generate" disabled="@(IsRunning || !HasRun)">
            Generate AI Image
        </button>
        
        <div class="speed-control">
            <label for="speedSlider">Speed: @SimulationSpeed</label>
            <input type="range" id="speedSlider" min="1" max="20" step="1" @bind="SimulationSpeed" />
        </div>
    </div>

    <div class="content-area">
        <div class="grid-container" @onkeydown="(e) => HandleKeyDown(e.Key)" tabindex="0">
            <div class="grid" style="grid-template-columns: repeat(@GridSize, 1fr);">
                @for (int y = 0; y < GridSize; y++)
                {
                    @for (int x = 0; x < GridSize; x++)
                    {
                        int row = y;
                        int col = x;
                        <div class="cell @(Grid[row, col] ? "alive" : "")"
                             @onclick="() => ToggleCell(row, col)"
                             style="@(Grid[row, col] ? $"background-color: {CellColors[row, col]}" : "")">
                        </div>
                    }
                }
            </div>
            
            <div class="stats">
                <p>Generation: @Generation</p>
                <p>Living Cells: @CountLivingCells()</p>
            </div>
        </div>
        
        <div class="image-container">
            @if (IsLoading)
            {
                <div class="loading">Generating image...</div>
            }
            else if (!string.IsNullOrEmpty(ImageUrl))
            {
                <div class="ai-image">
                    <h3>AI Visualization</h3>
                    <img src="@ImageUrl" alt="AI Generated Image" />
                    <div class="image-prompt-container">
                        <h4>Generated Prompt:</h4>
                        <p class="image-prompt">@LastPrompt</p>
                    </div>
                </div>
            }
            else if (HasRun && !IsRunning)
            {
                <div class="no-image">
                    <p>Pause simulation and click "Generate AI Image" to visualize this pattern</p>
                </div>
            }
            else
            {
                <div class="instructions">
                    <h3>Instructions</h3>
                    <ol>
                        <li>Click cells to set initial pattern or use "Randomize"</li>
                        <li>Press "Start" to begin simulation</li>
                        <li>Press "Pause" when you see an interesting pattern</li>
                        <li>Click "Generate AI Image" to visualize the pattern</li>
                    </ol>
                    <p>You can also press Spacebar to toggle simulation.</p>
                </div>
            }
        </div>
    </div>
</div>

@code {
    // Grid settings
    private const int GridSize = 30;
    private bool[,] Grid = new bool[GridSize, GridSize];
    private bool[,] NextGrid = new bool[GridSize, GridSize];
    private string[,] CellColors = new string[GridSize, GridSize];
    private string[,] NextCellColors = new string[GridSize, GridSize];
    
    // Pattern selection
    private string SelectedPattern = "";
    
    // Available colors for cells
    private readonly string[] ColorPalette = new string[] {
        "#FF5252", "#FF4081", "#E040FB", "#7C4DFF", "#536DFE", 
        "#448AFF", "#40C4FF", "#18FFFF", "#64FFDA", "#69F0AE", 
        "#B2FF59", "#EEFF41", "#FFFF00", "#FFD740", "#FFAB40"
    };
    
    // Simulation settings
    private Timer SimulationTimer;
    private bool IsRunning = false;
    private bool HasRun = false;
    private int Generation = 0;
    private int SimulationSpeed = 10;
    
    // Image generation
    private string ImageUrl = "";
    private string LastPrompt = "";
    private bool IsLoading = false;
    
    // API settings - in a production app, store these securely
    private readonly string ApiEndpoint = "https://api.your-llm-provider.com/generate";
    private readonly string ApiKey = "your-api-key";
    
    protected override void OnInitialized()
    {
        SimulationTimer = new Timer(1000 / SimulationSpeed);
        SimulationTimer.Elapsed += (sender, args) => InvokeAsync(RunSimulationStep);
        InitializeCellColors();
    }
    
    private void InitializeCellColors()
    {
        Random random = new Random();
        for (int y = 0; y < GridSize; y++)
        {
            for (int x = 0; x < GridSize; x++)
            {
                CellColors[y, x] = ColorPalette[random.Next(ColorPalette.Length)];
                NextCellColors[y, x] = ColorPalette[random.Next(ColorPalette.Length)];
            }
        }
    }
    
    private void ToggleCell(int row, int col)
    {
        if (!IsRunning)
        {
            Grid[row, col] = !Grid[row, col];
            if (Grid[row, col])
            {
                // Assign a random color when cell becomes alive
                CellColors[row, col] = GetRandomColor();
            }
            StateHasChanged();
        }
    }
    
    private string GetRandomColor()
    {
        Random random = new Random();
        return ColorPalette[random.Next(ColorPalette.Length)];
    }
    
    private void ToggleSimulation()
    {
        IsRunning = !IsRunning;
        
        if (IsRunning)
        {
            HasRun = true;
            SimulationTimer.Interval = 1000 / SimulationSpeed;
            SimulationTimer.Start();
        }
        else
        {
            SimulationTimer.Stop();
        }
    }
    
    private void ResetGrid()
    {
        if (!IsRunning)
        {
            Grid = new bool[GridSize, GridSize];
            Generation = 0;
            HasRun = false;
            InitializeCellColors();
            StateHasChanged();
        }
    }
    
    private void ApplySelectedPattern()
    {
        if (!IsRunning && !string.IsNullOrEmpty(SelectedPattern))
        {
            // Clear the grid first
            Grid = new bool[GridSize, GridSize];
            
            // Apply the selected pattern
            switch (SelectedPattern)
            {
                case "blinker":
                    CreateBlinker();
                    break;
                case "toad":
                    CreateToad();
                    break;
                case "beacon":
                    CreateBeacon();
                    break;
                case "pulsar":
                    CreatePulsar();
                    break;
                case "glider":
                    CreateGlider();
                    break;
                case "lwss":
                    CreateLightweightSpaceship();
                    break;
                case "glider_gun":
                    CreateGosperGliderGun();
                    break;
                case "random":
                    RandomizeGrid();
                    return; // RandomizeGrid already has its own implementation
                default:
                    return;
            }
            
            // Assign colors to the cells that are now alive
            for (int y = 0; y < GridSize; y++)
            {
                for (int x = 0; x < GridSize; x++)
                {
                    if (Grid[y, x])
                    {
                        CellColors[y, x] = GetRandomColor();
                    }
                }
            }
            
            StateHasChanged();
        }
    }
    
    private void CreateBlinker()
    {
        // Place a blinker oscillator in the middle of the grid
        int centerY = GridSize / 2;
        int centerX = GridSize / 2;
        
        Grid[centerY - 1, centerX] = true;
        Grid[centerY, centerX] = true;
        Grid[centerY + 1, centerX] = true;
    }
    
    private void CreateToad()
    {
        // Place a toad oscillator in the middle of the grid
        int centerY = GridSize / 2;
        int centerX = GridSize / 2;
        
        Grid[centerY, centerX - 1] = true;
        Grid[centerY, centerX] = true;
        Grid[centerY, centerX + 1] = true;
        Grid[centerY + 1, centerX - 2] = true;
        Grid[centerY + 1, centerX - 1] = true;
        Grid[centerY + 1, centerX] = true;
    }
    
    private void CreateBeacon()
    {
        // Place a beacon oscillator in the middle of the grid
        int centerY = GridSize / 2;
        int centerX = GridSize / 2;
        
        Grid[centerY - 1, centerX - 1] = true;
        Grid[centerY - 1, centerX] = true;
        Grid[centerY, centerX - 1] = true;
        Grid[centerY, centerX] = true;
        
        Grid[centerY + 1, centerX + 1] = true;
        Grid[centerY + 1, centerX + 2] = true;
        Grid[centerY + 2, centerX + 1] = true;
        Grid[centerY + 2, centerX + 2] = true;
    }
    
    private void CreatePulsar()
    {
        // Place a pulsar oscillator in the middle of the grid
        int centerY = GridSize / 2;
        int centerX = GridSize / 2;
        
        // Place the central pattern (simplified pulsar)
        for (int offset = -4; offset <= 4; offset += 4)
        {
            // Horizontal lines
            for (int i = -2; i <= 2; i++)
            {
                if (i != 0)
                {
                    Grid[centerY + offset, centerX + i] = true;
                    Grid[centerY - offset, centerX + i] = true;
                }
            }
            
            // Vertical lines
            for (int i = -2; i <= 2; i++)
            {
                if (i != 0)
                {
                    Grid[centerY + i, centerX + offset] = true;
                    Grid[centerY + i, centerX - offset] = true;
                }
            }
        }
    }
    
    private void CreateGlider()
    {
        // Place a glider in the top-left quadrant
        int startY = GridSize / 4;
        int startX = GridSize / 4;
        
        Grid[startY, startX + 1] = true;
        Grid[startY + 1, startX + 2] = true;
        Grid[startY + 2, startX] = true;
        Grid[startY + 2, startX + 1] = true;
        Grid[startY + 2, startX + 2] = true;
    }
    
    private void CreateLightweightSpaceship()
    {
        // Place a lightweight spaceship in the left side
        int startY = GridSize / 2;
        int startX = GridSize / 4;
        
        Grid[startY, startX + 1] = true;
        Grid[startY, startX + 4] = true;
        Grid[startY + 1, startX] = true;
        Grid[startY + 2, startX] = true;
        Grid[startY + 2, startX + 4] = true;
        Grid[startY + 3, startX] = true;
        Grid[startY + 3, startX + 1] = true;
        Grid[startY + 3, startX + 2] = true;
        Grid[startY + 3, startX + 3] = true;
    }
    
    private void CreateGosperGliderGun()
    {
        // Place the Gosper Glider Gun pattern in the grid
        int startY = GridSize / 2 - 5;
        int startX = 10;
        
        // Left square
        Grid[startY + 4, startX] = true;
        Grid[startY + 4, startX + 1] = true;
        Grid[startY + 5, startX] = true;
        Grid[startY + 5, startX + 1] = true;
        
        // Right square
        Grid[startY + 4, startX + 34] = true;
        Grid[startY + 4, startX + 35] = true;
        Grid[startY + 5, startX + 34] = true;
        Grid[startY + 5, startX + 35] = true;
        
        // Left pattern
        Grid[startY + 2, startX + 13] = true;
        Grid[startY + 3, startX + 12] = true;
        Grid[startY + 3, startX + 14] = true;
        Grid[startY + 4, startX + 11] = true;
        Grid[startY + 4, startX + 15] = true;
        Grid[startY + 5, startX + 11] = true;
        Grid[startY + 5, startX + 15] = true;
        Grid[startY + 5, startX + 16] = true;
        Grid[startY + 5, startX + 17] = true;
        Grid[startY + 6, startX + 11] = true;
        Grid[startY + 6, startX + 15] = true;
        Grid[startY + 7, startX + 12] = true;
        Grid[startY + 7, startX + 14] = true;
        Grid[startY + 8, startX + 13] = true;
        
        // Right pattern
        Grid[startY + 2, startX + 25] = true;
        Grid[startY + 3, startX + 23] = true;
        Grid[startY + 3, startX + 25] = true;
        Grid[startY + 4, startX + 21] = true;
        Grid[startY + 4, startX + 22] = true;
        Grid[startY + 5, startX + 21] = true;
        Grid[startY + 5, startX + 22] = true;
        Grid[startY + 6, startX + 21] = true;
        Grid[startY + 6, startX + 22] = true;
        Grid[startY + 7, startX + 23] = true;
        Grid[startY + 7, startX + 25] = true;
        Grid[startY + 8, startX + 25] = true;
    }
    
    private void RandomizeGrid()
    {
        if (!IsRunning)
        {
            Random random = new Random();
            for (int y = 0; y < GridSize; y++)
            {
                for (int x = 0; x < GridSize; x++)
                {
                    Grid[y, x] = random.Next(0, 100) < 20; // 20% chance for a cell to be alive
                    if (Grid[y, x])
                    {
                        CellColors[y, x] = ColorPalette[random.Next(ColorPalette.Length)];
                    }
                }
            }
            StateHasChanged();
        }
    }
    
    private void RunSimulationStep()
    {
        // Copy grid to avoid modifying it while iterating
        for (int y = 0; y < GridSize; y++)
        {
            for (int x = 0; x < GridSize; x++)
            {
                int neighbors = CountNeighbors(y, x);
                
                // Apply Game of Life rules
                if (Grid[y, x])
                {
                    // Any live cell with fewer than 2 or more than 3 live neighbors dies
                    NextGrid[y, x] = neighbors == 2 || neighbors == 3;
                    if (NextGrid[y, x])
                    {
                        // Keep the same color if the cell stays alive
                        NextCellColors[y, x] = CellColors[y, x];
                    }
                }
                else
                {
                    // Any dead cell with exactly 3 live neighbors becomes alive
                    NextGrid[y, x] = neighbors == 3;
                    if (NextGrid[y, x])
                    {
                        // New cell gets a random color or inherits from neighbors
                        NextCellColors[y, x] = GetRandomColor();
                    }
                }
            }
        }
        
        // Swap grids
        var tempGrid = Grid;
        Grid = NextGrid;
        NextGrid = tempGrid;
        
        var tempColors = CellColors;
        CellColors = NextCellColors;
        NextCellColors = tempColors;
        
        Generation++;
        StateHasChanged();
    }
    
    private int CountNeighbors(int row, int col)
    {
        int count = 0;
        
        for (int y = -1; y <= 1; y++)
        {
            for (int x = -1; x <= 1; x++)
            {
                if (y == 0 && x == 0) continue; // Skip the cell itself
                
                // Wrap around grid edges (toroidal grid)
                int neighborRow = (row + y + GridSize) % GridSize;
                int neighborCol = (col + x + GridSize) % GridSize;
                
                if (Grid[neighborRow, neighborCol])
                {
                    count++;
                }
            }
        }
        
        return count;
    }
    
    private int CountLivingCells()
    {
        int count = 0;
        for (int y = 0; y < GridSize; y++)
        {
            for (int x = 0; x < GridSize; x++)
            {
                if (Grid[y, x]) count++;
            }
        }
        return count;
    }
    
    private string GeneratePatternDescription()
    {
        // Analyze the current Game of Life grid pattern
        int livingCells = CountLivingCells();
        double density = (double)livingCells / (GridSize * GridSize);
        
        // Get pattern characteristics
        var clusters = IdentifyClusters();
        bool hasSymmetry = DetectSymmetry();
        bool hasOscillator = Generation > 5;
        
        // Determine the type of natural scene based on pattern characteristics
        string naturalSubject = GetNaturalSubject(clusters, hasSymmetry, density);
        string environment = GetNaturalEnvironment(density, hasOscillator);
        string activity = GetNaturalActivity(clusters.Count, hasOscillator);
        string timeOfDay = GetRandomTimeOfDay();
        string weatherCondition = GetRandomWeatherCondition();
        
        // Generate artistic direction
        string visualStyle = GetRandomVisualStyle();
        string lighting = GetRandomLighting();
        
        // Build the final prompt
        string finalPrompt = $"A nature photograph of {naturalSubject} {activity} in {environment} during {timeOfDay} with {weatherCondition}. " +
                             $"The {visualStyle} image should have {lighting} lighting. " +
                             $"The scene should capture the intricate patterns, relationships, and emergent behaviors found in Conway's Game of Life cellular automaton.";
        
        return finalPrompt;
    }
    private List<int> IdentifyClusters()
    {
        // A simple cluster identification algorithm using flood fill
        bool[,] visited = new bool[GridSize, GridSize];
        List<int> clusterSizes = new List<int>();
        
        for (int y = 0; y < GridSize; y++)
        {
            for (int x = 0; x < GridSize; x++)
            {
                if (Grid[y, x] && !visited[y, x])
                {
                    int size = FloodFill(y, x, visited);
                    clusterSizes.Add(size);
                }
            }
        }
        
        // Sort by size (largest first)
        clusterSizes.Sort((a, b) => b.CompareTo(a));
        return clusterSizes;
    }

    private int FloodFill(int row, int col, bool[,] visited)
    {
        // Check bounds, cell state, and if already visited
        if (row < 0 || row >= GridSize || col < 0 || col >= GridSize || 
            !Grid[row, col] || visited[row, col])
            return 0;
        
        visited[row, col] = true;
        int size = 1;
        
        // Check 8 neighbors
        for (int y = -1; y <= 1; y++)
        {
            for (int x = -1; x <= 1; x++)
            {
                if (y == 0 && x == 0) continue; // Skip the current cell
                
                // Handle wrapping around edges (toroidal grid)
                int neighborRow = (row + y + GridSize) % GridSize;
                int neighborCol = (col + x + GridSize) % GridSize;
                
                size += FloodFill(neighborRow, neighborCol, visited);
            }
        }
        
        return size;
    }
    
    private string GetNaturalSubject(List<int> clusters, bool hasSymmetry, double density)
    {
        // Animals for different pattern types
        string[] smallCreatures = {
            "a colony of ants", "a swarm of honeybees", "a cluster of butterflies",
            "a group of ladybugs", "tiny hummingbirds", "colorful dragonflies",
            "iridescent beetles", "monarch butterflies", "fireflies", "damselflies"
        };
        
        string[] largeAnimals = {
            "a herd of zebras", "a flock of flamingos", "a pod of dolphins",
            "a school of fish", "a murmuration of starlings", "a pride of lions",
            "a tower of giraffes", "a group of peacocks", "a parliament of owls"
        };
        
        string[] symmetricalAnimals = {
            "monarch butterflies with symmetrical wing patterns", "peacocks with displayed feathers",
            "jellyfish with radial bodies", "sea stars", "snowflake-patterned beetles", 
            "turtles with patterned shells", "tropical fish with mirror-image markings"
        };
        
        Random random = new Random();
        
        // Choose animal type based on pattern characteristics
        if (hasSymmetry)
        {
            return symmetricalAnimals[random.Next(symmetricalAnimals.Length)];
        }
        else if (clusters.Count == 1 && clusters[0] > 20 || density > 0.3)
        {
            return largeAnimals[random.Next(largeAnimals.Length)];
        }
        else
        {
            return smallCreatures[random.Next(smallCreatures.Length)];
        }
    }

    private string GetNaturalEnvironment(double density, bool hasOscillator)
    {
        string[] denseEnvironments = {
            "a lush rainforest", "a dense coral reef", "a vibrant meadow of wildflowers",
            "an ancient redwood forest", "a thriving wetland ecosystem", "a jungle canopy",
            "a rich kelp forest", "a blooming botanical garden"
        };
        
        string[] sparseEnvironments = {
            "an open savanna", "a serene desert landscape", "rolling sand dunes",
            "a rocky coastal shore", "an alpine meadow", "a sparse tundra",
            "a tranquil pond", "a misty mountain range"
        };
        
        string[] dynamicEnvironments = {
            "churning river rapids", "tidal pools at the ocean's edge", "wind-swept grasslands",
            "a dynamic estuary", "shifting sand formations", "waves breaking on a reef",
            "a forest during changing seasons", "a prairie during migration season"
        };
        
        Random random = new Random();
        
        if (hasOscillator)
        {
            return dynamicEnvironments[random.Next(dynamicEnvironments.Length)];
        }
        else if (density > 0.25)
        {
            return denseEnvironments[random.Next(denseEnvironments.Length)];
        }
        else
        {
            return sparseEnvironments[random.Next(sparseEnvironments.Length)];
        }
    }

    private string GetNaturalActivity(int clusterCount, bool hasOscillator)
    {
        string[] activities = {
            "foraging for food", "building nests", "migrating across", "communicating with each other",
            "following natural patterns", "adapting to their environment", "displaying courtship behaviors",
            "creating geometric formations", "following murmurations", "demonstrating swarm intelligence"
        };
        
        string[] cyclicActivities = {
            "flowing in rhythmic patterns", "moving in synchronization", "creating circular formations",
            "performing a natural dance", "cycling through seasonal behaviors", "pulsing with life",
            "creating rippling patterns", "moving in wave-like formations"
        };
        
        string[] groupActivities = {
            "forming complex social structures", "creating protective formations",
            "coordinating group movement", "sharing resources", "participating in symbiotic relationships",
            "establishing territories", "collaborating for survival"
        };
        
        Random random = new Random();
        
        if (hasOscillator)
        {
            return cyclicActivities[random.Next(cyclicActivities.Length)];
        }
        else if (clusterCount > 3)
        {
            return groupActivities[random.Next(groupActivities.Length)];
        }
        else
        {
            return activities[random.Next(activities.Length)];
        }
    }

    private string GetRandomTimeOfDay()
    {
        string[] timesOfDay = {
            "early morning", "golden hour sunrise", "bright midday", "soft afternoon light",
            "golden hour sunset", "twilight", "dusk", "dawn", "the blue hour"
        };
        
        Random random = new Random();
        return timesOfDay[random.Next(timesOfDay.Length)];
    }

    private string GetRandomWeatherCondition()
    {
        string[] weatherConditions = {
            "clear skies", "gentle mist", "soft fog", "dappled sunlight",
            "light rain", "a gentle breeze", "scattered clouds", "morning dew",
            "golden sunlight", "crisp air", "shimmering heat waves"
        };
        
        Random random = new Random();
        return weatherConditions[random.Next(weatherConditions.Length)];
    }

    private string GetRandomVisualStyle()
    {
        string[] visualStyles = {
            "photorealistic", "high-definition nature documentary", "macro photography",
            "David Attenborough-style wildlife documentary", "National Geographic", "cinematic",
            "detailed wildlife photography", "professional nature photography"
        };
        
        Random random = new Random();
        return visualStyles[random.Next(visualStyles.Length)];
    }

    private string GetRandomLighting()
    {
        string[] lighting = {
            "natural", "soft", "dramatic", "backlit", "sidelit", "golden", 
            "diffused", "dappled", "atmospheric", "moody", "high-contrast"
        };
        
        Random random = new Random();
        return lighting[random.Next(lighting.Length)];
    }
    
    private bool DetectSymmetry()
    {
        // Check horizontal symmetry (simplified)
        for (int y = 0; y < GridSize; y++)
        {
            for (int x = 0; x < GridSize / 2; x++)
            {
                if (Grid[y, x] != Grid[y, GridSize - 1 - x])
                {
                    return false;
                }
            }
        }
        return true;
    }
    
    private async Task GenerateImage()
    {
        if (IsRunning || IsLoading) return;
        
        try
        {
            IsLoading = true;
            StateHasChanged();
            
            // Generate a prompt based on the current pattern
            LastPrompt = GeneratePatternDescription();
            
            // Make sure the prompt is not empty
            if (string.IsNullOrWhiteSpace(LastPrompt))
            {
                throw new Exception("Generated prompt is empty");
            }

            Console.WriteLine($"Sending prompt: {LastPrompt}");
            
            // Change this URL to your API server's URL
            string apiUrl = "https://localhost:5062/api/generate-image";
            
            // Make sure the property name matches what the API expects
            var request = new 
            {
                prompt = LastPrompt  // Note: changed to lowercase 'prompt' - case matters!
            };
            
            var response = await Http.PostAsJsonAsync(apiUrl, request);
            
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<EverArtResponse>();
                
                if (result?.data?.Count > 0 && !string.IsNullOrEmpty(result.data[0].url))
                {
                    ImageUrl = result.data[0].url;
                }
                else
                {
                    throw new Exception("No image URL in the response");
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"API error response: {errorContent}");
                throw new Exception($"API error: {response.StatusCode}. {errorContent}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error generating image: {ex.Message}");
            // Display error to user
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    // Add these classes to handle the EverArt API response
    public class EverArtResponse
    {
        public List<EverArtImage> data { get; set; }
    }

    public class EverArtImage
    {
        public string url { get; set; }
    }

    [JSInvokable]
    public void HandleKeyDown(string key)
    {
        if (key == " ") // Space key
        {
            ToggleSimulation();
        }
    }
    
    public void Dispose()
    {
        SimulationTimer?.Dispose();
    }
}